import java_cup.runtime.*;
import ir.ast.*;
import java.util.LinkedList;
import java.util.List;


parser code {:

        public void syntax_error(Symbol s){
            System.err.println("Syntax error in line " + (s.left+1) + " column " + (s.right+1) + " value : " + (s.value)); 
        }

        public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
            //System.err.println("Fatal Error");
            throw new java.lang.Exception("Fatal Error");
        }     
:}

terminal CLASS, VOID, INT, FLOAT, BOOLEAN, IF, ELSE, FOR, WHILE, RETURN, BREAK, CONTINUE, EXTERN, LEFTBRACE, RIGHTBRACE, LOGIC_NEGATION, LEFT_PAREN, RT_PAREN, LEFT_BRKT, RT_BRKT, SEMI, COMMA, POINT, ID, ERROR, TIMES, MINUS, PLUS, DIVIDE, MOD, AND, OR, EQ, GTR, LESS, LESS_EQ, GTR_EQ, NOT_EQ, ASSMNT, ASSMNT_INC, ASSMNT_DEC, INT_LITERAL, FLOAT_LITERAL, TRUE, FALSE;



non terminal String id_point_list;

non terminal Type type; 
non terminal Expression expr;
non terminal List<Expression> expr_list;

non terminal Block block, body_block;
non terminal List<Statement> statement_list;

non terminal ClassDecl class_decl, body_class;
non terminal List<ClassDecl> class_list, program;

non terminal List<FieldDecl> field_list;
non terminal FieldDecl field_decl;

non terminal MethodDecl method_decl;
non terminal List<MethodDecl> method_list;


non terminal Literal literal;
non terminal Location location, type_id;
non terminal VarLocation var_location;
non terminal List<Location> type_id_list;

non terminal Parameter parameter;
non terminal List<Parameter> parameters_list;

non terminal ArrayLocation array_location;
non terminal Statement statement, body;
non terminal MethodCall method_call; 

precedence left GTR,LESS,EQ,NOT_EQ,GTR_EQ,LESS_EQ,AND,OR;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence left LEFT_PAREN, RT_PAREN;
precedence left LOGIC_NEGATION;
precedence left ELSE;



start with program;



program ::= class_list:clist {: RESULT = clist ;:}
		  ;

class_list ::= class_decl:c {: LinkedList res = new LinkedList(); res.add(c); RESULT = res; :}
            |  class_list:clist class_decl:c {: clist.add(c); RESULT = clist; :}
            ;
                    
class_decl::= CLASS ID LEFTBRACE body_class:c RIGHTBRACE {: RESULT = c; :}
            | CLASS ID LEFTBRACE RIGHTBRACE {: RESULT = new ClassDecl(); :}
            ;

body_class ::= field_list:flist method_list:mlist {: RESULT = new ClassDecl(flist, mlist); :}
             | field_list:flist {: RESULT = new ClassDecl(flist, new LinkedList()); :}
             | method_list:mlist {: RESULT = new ClassDecl(new LinkedList(), mlist); :}
             ;

field_list::= field_list:fl field_decl:fd {: fl.add(fd); RESULT = fl; :}
            | field_decl:fd {:LinkedList res = new LinkedList(); res.add(fd); RESULT = res;:}
            ;
                
field_decl::= type:t type_id_list:tl SEMI {: RESULT = new FieldDecl(t,tl);:}
			;
        

type_id_list::= type_id:id {:LinkedList res = new LinkedList(); res.add(id); RESULT = res;:}
              | type_id:id COMMA type_id_list:id_list {: id_list.add(id); RESULT = id_list; :}
              ;
                    
type_id::= ID:id LEFT_BRKT INT_LITERAL:e RT_BRKT {:RESULT = new ArrayLocation((String)id, new IntLiteral((String)e)); :}
         | ID:id  {:RESULT = new VarLocation((String)id); :}               
         ;
                
method_list::= method_list:mlist method_decl:m {: mlist.add(m); RESULT = mlist; :} 
             | method_decl:m {: LinkedList res = new LinkedList(); res.add(m); RESULT = res ;:}
             ;

method_decl::= VOID ID:id LEFT_PAREN parameters_list:plist RT_PAREN body:b {: RESULT = new MethodDecl(Type.VOID, (String) id, plist, b);:}
             | type:t ID:id LEFT_PAREN parameters_list:plist RT_PAREN body:b {: RESULT = new MethodDecl(t, (String) id, plist, b);:}
             | VOID ID:id LEFT_PAREN RT_PAREN body:b {: RESULT = new MethodDecl(Type.VOID, (String) id, new LinkedList(), b);:}
             | type:t ID:id LEFT_PAREN RT_PAREN body:b {: RESULT = new MethodDecl(t, (String) id, new LinkedList(), b);:}
             ;

parameters_list::= parameter:p {: LinkedList res = new LinkedList(); res.add(p); RESULT = res; :}
                 | parameter:p COMMA parameters_list:plist {: plist.add(p); RESULT = plist; :}
                 ;
                        
parameter::= type:t ID:id {: RESULT = new Parameter(t,(String)id); :} 
		   ;

body::= block:b {:RESULT = b;:}
      | EXTERN SEMI {:RESULT = new ExternStmt();:}
      ;
        
block::= LEFTBRACE body_block:b RIGHTBRACE {: RESULT = b; :}
       | LEFTBRACE RIGHTBRACE {: RESULT = new Block(0); :}
       ;
       
body_block ::= field_list:fl statement_list:sl {: RESULT = new Block(0,sl,fl); :}
             | field_list:fl {:RESULT = new Block(0,new LinkedList(),fl);:}
             | statement_list:sl {:RESULT = new Block(0,sl,new LinkedList());:}
             ;

type::= INT {: RESULT = Type.INT ;:}
	  | FLOAT {: RESULT = Type.FLOAT ;:}
	  | BOOLEAN {: RESULT = Type.BOOLEAN ;:}
	  ;

statement_list::= statement_list:sl statement:s {: sl.add(s); RESULT = sl; :}
                | statement:s {: LinkedList res = new LinkedList(); res.add(s); RESULT = res; :}
                ;
                        
statement::= location:l ASSMNT expr:e SEMI {: RESULT = new AssignStmt(l,AssignOpType.ASSMNT,e); :}
           | location:l ASSMNT_INC expr:e SEMI {: RESULT = new AssignStmt(l,AssignOpType.ASSMNT_INC,e); :}
           | location:l ASSMNT_DEC expr:e SEMI {: RESULT = new AssignStmt(l,AssignOpType.ASSMNT_DEC,e); :}
           | method_call:m SEMI {: RESULT = new MethodCallStmt(m.getLocation(),m.getExpressions()); :}
           | IF LEFT_PAREN expr:e RT_PAREN statement:s1 ELSE statement:s2 {: RESULT = new IfStmt(e,s1,s2); :}
           | IF LEFT_PAREN expr:e RT_PAREN statement:s {: RESULT = new IfStmt(e,s); :}
           //| IF LEFT_PAREN expr RT_PAREN ifBlock ELSE elseBlock 
           //| IF LEFT_PAREN expr RT_PAREN ifBlock
           | FOR ID:id ASSMNT expr:e1 COMMA expr:e2 statement:s {: AssignStmt assign = new AssignStmt(new VarLocation((String)id),AssignOpType.ASSMNT,e1); RESULT = new ForStmt(assign,e2,s); :}
           | WHILE expr:e statement:s {: RESULT = new WhileStmt(e,s); :}
           | RETURN expr:e SEMI {: RESULT = new ReturnStmt(e); :}
           | RETURN SEMI {: RESULT = new ReturnStmt(); :}
           | BREAK SEMI {: RESULT = new BreakStmt(); :}
           | CONTINUE SEMI {: RESULT = new ContinueStmt(); :}
           | SEMI
           | block:b {: RESULT = b; :}
           ;
                                              
method_call::= var_location:l LEFT_PAREN expr_list:e RT_PAREN {:RESULT = new MethodCall(l,e);:}
             | var_location:l LEFT_PAREN RT_PAREN {:RESULT = new MethodCall(l);:}
             ;

location::= var_location:l {: RESULT = l;:}
		  | array_location:l {: RESULT = l;:} 
		  ;
          
var_location::= ID:id id_point_list:id_list {: RESULT = new VarLocation(((String)id)+id_list); :}
			  | ID:id {: RESULT = new VarLocation((String)id) ; :}
			  ;

array_location::= ID:id LEFT_BRKT expr:e RT_BRKT {: RESULT = new ArrayLocation(((String)id),e) ; :}
                | ID:id id_point_list:id_list LEFT_BRKT expr:e RT_BRKT {: RESULT = new ArrayLocation((((String)id)+id_list),e); :}
          		;

id_point_list::= id_point_list:id_list POINT:p ID:id {: RESULT = id_list+((String)p)+((String)id); :}
               |POINT:p ID:id {: RESULT = ((String)p)+((String)id); :}
               ;

expr_list::= expr:e COMMA expr_list:list {: list.add(e); RESULT = list; :}
           | expr:e {: LinkedList res = new LinkedList(); res.add(e); RESULT = res; :}
           ;
                
expr::= location:l {: RESULT = l ; :}
      | method_call:m {: RESULT = m ; :}
      | literal:l {: RESULT = l;:}
      | expr:e1 PLUS:o expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.PLUS,e2);:}
      | expr:e1 MINUS expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.MINUS,e2);:}
      | expr:e1 TIMES expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.TIMES,e2);:}
      | expr:e1 DIVIDE expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.DIVIDE,e2);:}
      | expr:e1 MOD expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.MOD,e2);:}
      | expr:e1 GTR expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.GTR,e2);:}
      | expr:e1 LESS expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.LESS,e2);:}
      | expr:e1 GTR_EQ expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.GTR_EQ,e2);:}
      | expr:e1 LESS_EQ expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.LESS_EQ,e2);:}
      | expr:e1 EQ expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.EQ,e2);:}
      | expr:e1 NOT_EQ expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.NOT_EQ,e2);:}
      | expr:e1 AND expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.AND,e2);:}
      | expr:e1 OR expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.OR,e2);:}
      | MINUS expr:e {: RESULT = new UnOpExpr(UnOpType.MINUS, e); :}
      | LOGIC_NEGATION expr:e {: RESULT = new UnOpExpr(UnOpType.LOGIC_NEGATION, e); :}
      | LEFT_PAREN expr:e RT_PAREN {: RESULT = e ; :}
      ;
                            
literal::= INT_LITERAL:v {: RESULT = new IntLiteral((String)v); :}
         | FLOAT_LITERAL:v {: RESULT = new FloatLiteral((String)v); :}
         | TRUE:v {: RESULT = new BooleanLiteral((String)v); :}
         | FALSE:v {: RESULT = new BooleanLiteral((String)v); :}
         ;
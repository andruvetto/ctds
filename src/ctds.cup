import java_cup.runtime.*;
import ir.ast.*;
import java.util.LinkedList;
import java.util.List;


parser code {:

        public void syntax_error(Symbol s){
            System.err.println("Syntax error in line " + (s.left+1) + " column " + (s.right+1) + " value : " + (s.value)); 
        }

        public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
            //System.err.println("Fatal Error");
            throw new java.lang.Exception("Fatal Error");
        }
		
   
        
:}

terminal CLASS, VOID, INT, FLOAT, BOOLEAN, IF, ELSE, FOR, WHILE, RETURN, BREAK, CONTINUE, EXTERN, LEFTBRACE, RIGHTBRACE, LOGIC_NEGATION, LEFT_PAREN, RT_PAREN, LEFT_BRKT, RT_BRKT, SEMI, COMMA, POINT, ID, ERROR, TIMES, MINUS, PLUS, DIVIDE, MOD, AND, OR, EQ, GTR, LESS, LESS_EQ, GTR_EQ, NOT_EQ, ASSMNT, ASSMNT_INC, ASSMNT_DEC, INT_LITERAL, FLOAT_LITERAL, TRUE, FALSE;



non terminal program, class_list, class_decl, field_list, field_decl, type_id_list,method_list, method_decl, parameter, parameters_list, body, block, statement_list, body_class, body_block, type_id;

non terminal String id_point_list;

non terminal Type type, type_array; 
non terminal Expression expr;
non terminal List<Expression> expr_list;


non terminal Literal literal;
non terminal Location location;
non terminal VarLocation var_location;
non terminal ArrayLocation array_location;
non terminal Statement statement;
non terminal MethodCall method_call; 

precedence left GTR,LESS,EQ,NOT_EQ,GTR_EQ,LESS_EQ,AND,OR;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence left LEFT_PAREN, RT_PAREN;
precedence left LOGIC_NEGATION;
precedence left ELSE;



start with program;



program ::= class_list;

class_list ::= class_decl 
            |  class_list class_decl;
                    
class_decl::= CLASS ID LEFTBRACE body_class RIGHTBRACE
            | CLASS ID LEFTBRACE RIGHTBRACE;

body_class ::= field_list method_list
             | field_list
             | method_list;

field_list::= field_list field_decl
            | field_decl;
                
field_decl::= type type_id_list SEMI;
        

type_id_list::= type_id
              | type_id COMMA type_id_list;
                    
type_id::= ID LEFT_BRKT INT_LITERAL RT_BRKT
         | ID:id                 
         ;
                
method_list::= method_list method_decl 
             | method_decl;

method_decl::= VOID ID LEFT_PAREN parameters_list RT_PAREN body
             | type ID LEFT_PAREN parameters_list RT_PAREN body
             | VOID ID LEFT_PAREN RT_PAREN body
             | type ID LEFT_PAREN RT_PAREN body;
             

parameters_list::= parameter
                 | parameter COMMA parameters_list;
                        
parameter::= type ID;

body::= block
      | EXTERN SEMI;
        
block::= LEFTBRACE body_block RIGHTBRACE
       | LEFTBRACE RIGHTBRACE;
       
body_block ::= field_list statement_list
             | field_list
             | statement_list;

type::= INT {: RESULT = Type.INT ;:}
	  | FLOAT {: RESULT = Type.FLOAT ;:}
	  | BOOLEAN {: RESULT = Type.BOOLEAN ;:}
	  ;

//type_array ::= LEFT_BRKT INT_LITERAL RT_BRKT {: RESULT = Type.INTARRAY ;:};

statement_list::= statement_list statement
                | statement;
                        
statement::= location:l ASSMNT expr:e SEMI {: RESULT = new AssignStmt(l,AssignOpType.ASSMNT,e); :}
           | location:l ASSMNT_INC expr:e SEMI {: RESULT = new AssignStmt(l,AssignOpType.ASSMNT_INC,e); :}
           | location:l ASSMNT_DEC expr:e SEMI {: RESULT = new AssignStmt(l,AssignOpType.ASSMNT_DEC,e); :}
           | method_call:m SEMI
           | IF LEFT_PAREN expr:e RT_PAREN statement:s1 ELSE statement:s2 {: RESULT = new IfStmt(e,s1,s2); :}
           | IF LEFT_PAREN expr:e RT_PAREN statement:s {: RESULT = new IfStmt(e,s); :}
           //| IF LEFT_PAREN expr RT_PAREN ifBlock ELSE elseBlock 
           //| IF LEFT_PAREN expr RT_PAREN ifBlock
           | FOR ID:id ASSMNT expr:e1 COMMA expr:e2 statement:s {: AssignStmt assign = new AssignStmt(new VarLocation((String)id),AssignOpType.ASSMNT,e1); RESULT = new ForStmt(assign,e2,s); :}
           | WHILE expr:e statement:s {: RESULT = new WhileStmt(e,s); :}
           | RETURN expr:e SEMI {: RESULT = new ReturnStmt(e); :}
           | RETURN SEMI {: RESULT = new ReturnStmt(); :}
           | BREAK SEMI
           | CONTINUE SEMI
           | SEMI
           | block
           ;
                                              

method_call::= var_location:l LEFT_PAREN expr_list:e RT_PAREN {:RESULT = new MethodCall(l,e);:}
             | var_location:l LEFT_PAREN RT_PAREN {:RESULT = new MethodCall(l);:}
             ;

location::= var_location:l {: RESULT = l;:}
		  | array_location:l {: RESULT = l;:} 
		  ;
          


var_location::= ID:id id_point_list:id_list {: RESULT = new VarLocation(((String)id)+id_list); :}
			  | ID:id {: RESULT = new VarLocation((String)id) ; :}
			  ;

array_location::= ID:id LEFT_BRKT expr:e RT_BRKT {: RESULT = new ArrayLocation(((String)id),e) ; :}
                | ID:id id_point_list:id_list LEFT_BRKT expr:e RT_BRKT {: RESULT = new ArrayLocation((((String)id)+id_list),e); :}
          		;


id_point_list::= id_point_list:id_list POINT:p ID:id {: RESULT = id_list+((String)p)+((String)id); :}
               |POINT:p ID:id {: RESULT = ((String)p)+((String)id); :}
               ;


expr_list::= expr:e COMMA expr_list:list {: list.add(e); RESULT = list; :}
           | expr:e {: LinkedList res = new LinkedList(); res.add(e); RESULT = res; :}
           ;
                
expr::= location:l {: RESULT = l ; :}
      | method_call:m {: RESULT = m ; :}
      | literal:l {: RESULT = l;:}
      | expr:e1 PLUS:o expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.PLUS,e2);:}
      | expr:e1 MINUS expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.MINUS,e2);:}
      | expr:e1 TIMES expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.TIMES,e2);:}
      | expr:e1 DIVIDE expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.DIVIDE,e2);:}
      | expr:e1 MOD expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.MOD,e2);:}
      | expr:e1 GTR expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.GTR,e2);:}
      | expr:e1 LESS expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.LESS,e2);:}
      | expr:e1 GTR_EQ expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.GTR_EQ,e2);:}
      | expr:e1 LESS_EQ expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.LESS_EQ,e2);:}
      | expr:e1 EQ expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.EQ,e2);:}
      | expr:e1 NOT_EQ expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.NOT_EQ,e2);:}
      | expr:e1 AND expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.AND,e2);:}
      | expr:e1 OR expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.OR,e2);:}
      | MINUS expr:e {: RESULT = new UnOpExpr(UnOpType.MINUS, e); :}
      | LOGIC_NEGATION expr:e {: RESULT = new UnOpExpr(UnOpType.LOGIC_NEGATION, e); :}
      | LEFT_PAREN expr:e RT_PAREN {: RESULT = e ; :}
      ;
        
                    
literal::= INT_LITERAL:v {: RESULT = new IntLiteral((String)v); :}
         | FLOAT_LITERAL:v {: RESULT = new FloatLiteral((String)v); :}
         | TRUE:v {: RESULT = new BooleanLiteral((String)v); :}
         | FALSE:v {: RESULT = new BooleanLiteral((String)v); :}
         ;
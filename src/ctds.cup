import java_cup.runtime.*;
import ir.ast.*;


parser code {:

        public void syntax_error(Symbol s){
            System.err.println("Syntax error in line " + (s.left+1) + " column " + (s.right+1) + " value : " + (s.value)); 
        }

        public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
            //System.err.println("Fatal Error");
            throw new java.lang.Exception("Fatal Error");
        }
		
   
        
:}

terminal CLASS, VOID, INT, FLOAT, BOOLEAN, IF, ELSE, FOR, WHILE, RETURN, BREAK, CONTINUE, EXTERN, LEFTBRACE, RIGHTBRACE, LOGIC_NEGATION, LEFT_PAREN, RT_PAREN, LEFT_BRKT, RT_BRKT, SEMI, COMMA, POINT, ID, ERROR, TIMES, MINUS, PLUS, DIVIDE, MOD, AND, OR, EQ, GTR, LESS, LESS_EQ, GTR_EQ, NOT_EQ, ASSMNT, ASSMNT_INC, ASSMNT_DEC, INT_LITERAL, FLOAT_LITERAL, TRUE, FALSE;



non terminal program, class_list, class_decl, field_list, field_decl, type_id_list,method_list, method_decl, parameter, parameters_list, body, block, type, statement_list, method_call, id_point_list, expr_list, body_class, body_block;



non terminal Type type_id; 
non terminal Expression expr;
non terminal Literal literal;
non terminal Location location;
non terminal Statement statement; 

precedence left GTR,LESS,EQ,NOT_EQ,GTR_EQ,LESS_EQ,AND,OR;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence left LEFT_PAREN, RT_PAREN;
precedence left LOGIC_NEGATION;
precedence left ELSE;



start with program;



program ::= class_list;

class_list ::= class_decl 
            |  class_list class_decl;
                    
class_decl::= CLASS ID LEFTBRACE body_class RIGHTBRACE
            | CLASS ID LEFTBRACE RIGHTBRACE;

body_class ::= field_list method_list
             | field_list
             | method_list;

field_list::= field_list field_decl
            | field_decl;
                
field_decl::= type type_id_list SEMI;
        

type_id_list::= type_id
              | type_id COMMA type_id_list;
                    
type_id::= ID LEFT_BRKT INT_LITERAL RT_BRKT
         | ID:id 
                  
         ;
                
method_list::= method_list method_decl 
             | method_decl;

method_decl::= VOID ID LEFT_PAREN parameters_list RT_PAREN body
             | type ID LEFT_PAREN parameters_list RT_PAREN body
             | VOID ID LEFT_PAREN RT_PAREN body
             | type ID LEFT_PAREN RT_PAREN body;
             

parameters_list::= parameter
                 | parameter COMMA parameters_list;
                        
parameter::= type ID;

body::= block
      | EXTERN SEMI;
        
block::= LEFTBRACE body_block RIGHTBRACE
       | LEFTBRACE RIGHTBRACE;
       
body_block ::= field_list statement_list
             | field_list
             | statement_list;

type::= INT | FLOAT | BOOLEAN;

statement_list::= statement_list statement
                | statement;
                        
statement::= location:l ASSMNT expr:e SEMI {: RESULT = new AssignStmt(l,AssignOpType.ASSMNT,e); :}
           | location:l ASSMNT_INC expr:e SEMI {: RESULT = new AssignStmt(l,AssignOpType.ASSMNT_INC,e); :}
           | location:l ASSMNT_DEC expr:e SEMI {: RESULT = new AssignStmt(l,AssignOpType.ASSMNT_DEC,e); :}
           | method_call SEMI
           | IF LEFT_PAREN expr:e RT_PAREN statement:s1 ELSE statement:s2 {: RESULT = new IfStmt(e,s1,s2); :}
           | IF LEFT_PAREN expr:e RT_PAREN statement:s {: RESULT = new IfStmt(e,s); :}
           //| IF LEFT_PAREN expr RT_PAREN ifBlock ELSE elseBlock 
           //| IF LEFT_PAREN expr RT_PAREN ifBlock
           | FOR ID ASSMNT expr:e1 COMMA expr:e2 statement:s {: RESULT = new ForStmt(e1,e2,s); :}
           | WHILE expr:e statement:s {: RESULT = new WhileStmt(e,s); :}
           | RETURN expr:e SEMI {: RESULT = new ReturnStmt(e); :}
           | RETURN SEMI {: RESULT = new ReturnStmt(); :}
           | BREAK SEMI
           | CONTINUE SEMI
           | SEMI
           | block;
                                              

method_call::= ID id_point_list LEFT_PAREN expr_list RT_PAREN
             | ID LEFT_PAREN expr_list RT_PAREN
             | ID LEFT_PAREN RT_PAREN
             | ID id_point_list LEFT_PAREN RT_PAREN;

location::= ID id_point_list 
          | ID
          | ID LEFT_BRKT expr RT_BRKT
          | ID id_point_list LEFT_BRKT expr RT_BRKT; 

id_point_list::= id_point_list POINT ID 
               |POINT ID;


expr_list::= expr COMMA expr_list
           | expr;
                
expr::= location
      | method_call
      | literal:l {: RESULT = l;:}
      | expr:e1 PLUS:o expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.PLUS,e2);:}
      | expr:e1 MINUS expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.MINUS,e2);:}
      | expr:e1 TIMES expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.TIMES,e2);:}
      | expr:e1 DIVIDE expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.DIVIDE,e2);:}
      | expr:e1 MOD expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.MOD,e2);:}
      | expr:e1 GTR expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.GTR,e2);:}
      | expr:e1 LESS expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.LESS,e2);:}
      | expr:e1 GTR_EQ expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.GTR_EQ,e2);:}
      | expr:e1 LESS_EQ expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.LESS_EQ,e2);:}
      | expr:e1 EQ expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.EQ,e2);:}
      | expr:e1 NOT_EQ expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.NOT_EQ,e2);:}
      | expr:e1 AND expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.AND,e2);:}
      | expr:e1 OR expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.OR,e2);:}
      | MINUS expr:e {: RESULT = new UnOpExpr(UnOpType.MINUS, e); :}
      | LOGIC_NEGATION expr:e {: RESULT = new UnOpExpr(UnOpType.LOGIC_NEGATION, e); :}
      | LEFT_PAREN expr:e RT_PAREN {: RESULT = e ; :}
      ;
        
                    
literal::= INT_LITERAL:v {: RESULT = new IntLiteral((String)v); :}
         | FLOAT_LITERAL:v {: RESULT = new FloatLiteral((String)v); :}
         | TRUE:v {: RESULT = new BooleanLiteral((String)v); :}
         | FALSE:v {: RESULT = new BooleanLiteral((String)v); :}
         ;